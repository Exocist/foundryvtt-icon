import { IconActor } from "../../documents/actor";
import { IconItem } from "../../documents/item";
import { writable } from "svelte/store";

// //////////// HERE BE DRAGON DROPS ////////////
// Very useful:
// https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/Drag_operations#drop
// more raw api data:
// https://developer.mozilla.org/en-US/docs/Web/API/Document/drag_event

/**
 * @typedef {object} ResolvedItemDrop
 *
 * @property {"Item"} type Type is an Item
 *
 * @property {IconItem} document Resolved Document
 */

/**
 * @typedef {object} ResolvedActorDrop
 *
 * @property {"Actor"} type Type is an Actor
 *
 * @property {IconActor} document Resolved Document
 */

/**
 * @typedef {object} ResolvedMacroDrop
 *
 * @property {"Macro"} type Type is a macro
 *
 * @property {Macro} document Resolved Document
 */

/**
 * @typedef {ResolvedItemDrop | ResolvedActorDrop | ResolvedMacroDrop} ResolvedDrop
 * A union type of all the resolved drops we could have
 */


/**
 * @typedef {object} FoundryDropData Dragged data as generated by foundry
 *
 * @property {"Actor" | "Item" | "JournalEntry" | "Macro" | "Scene"} type The type of dragged object
 *
 * @property {string} uuid The dragged document's uuid
 */

/** 
 * Safely parse a JSON string, returning null on failure instead of throwing an exception
 *
 * @param {string} str The string to parse
 *
 * @returns {any} Parsed json or null
 */
export function safeParseJSON(str) {
    try {
        let result = JSON.parse(str);
        return result;
    } catch {
        return null;
    }
}

// Resolves a native foundry actor/item drop event datatransfer to the actual contained actor/item/journal
// This can be annoying, so we made it a dedicated method
// Input is either a stringified JSON dropData or a uuid

/**
 * Converts a foundry drop into our resolved drop
 * 
 * @param {string | FoundryDropData} drop The raw drop data, either as string uuid, a Foundry Drop, or JSON of a Foundry drop
 *
 * @returns {Promise<ResolvedDrop | null>} Promise yielding the resolved drop data, or null on failure
 */
export async function resolveNativeDrop(drop) {
    // Get dropped data
    let parsed_drop = drop;
    if (typeof drop == "string") {
        parsed_drop = safeParseJSON(drop);
    }
    if (parsed_drop.uuid) {
        parsed_drop = parsed_drop.uuid;
    }
    if (typeof parsed_drop == "string") {
        // Either wasn't an object, or failed to parse to be one from a stringAttempt uuid route
        let document = await fromUuid(parsed_drop);
        if (!document) {
            return null;
        }
        return document;
    }
    return null;
}

// A basic cache suitable for native drop lookups - a common task
// export type DragFetcherCache = FetcherCache<string | FoundryDropData, ResolvedDropData | null>;
// export function dragResolverCache(): DragFetcherCache {
// return new FetcherCache(resolve_native_drop);
// }

// GlobalDragState 

/** 
 * Store containing resolved foundry document of whatever is being dragged, if a document can be resolved
 * Note: not cleared even when a drag is over.
 */
export let DRAGGED_DOCUMENT = writable(null);

/**
 * Store containing whether dragging is currently occurring
 */
export let DRAGGING = writable(false);

// Setup global drag resolution
/**
 *
 */
export function applyGlobalDragListeners() {
    let body = document.getElementsByTagName("body")[0];
    let cancel_token = { canceled: false };

    // Capture when we start dragging anything anywhere - this covers regrefs and native drags
    body.addEventListener(
        "dragstart",
        (evt) => {
            // Clear whatever was there before
            DRAGGED_DOCUMENT.set(null);
            DRAGGING.set(true);

            // Attempt to recover the item
            let target = evt.target;
            let uuid = "";
            if (target?.dataset?.uuid) {
                // Is our set uuid
                uuid = target.dataset.uuid;
            } else if (target?.dataset?.documentId) {
                // Is a foundry sidebar or compendium drag
                let sbt = $(target).parents(".sidebar-tab")[0];
                if (sbt?.dataset?.tab) {
                    // Can deduce type based on the tab
                    let tab = sbt.dataset.tab;
                    uuid = `${tab.charAt(0).capitalize()}${tab.slice(1, tab.length - 1)}.${target.dataset.documentId}`;
                } else {
                    let cd = $(target).parents(".compendium.directory")[0];
                    if (cd) {
                        // Can deduce pack based on the directory
                        let pack = cd.dataset.pack;
                        uuid = `Compendium.${pack}.${target.dataset.documentId}`;
                    }
                }
            } else {
                return; // Not a uuid
            }

            // May or may not have a uuid by now
            // If we do, tell it to try setting global drag
            let cancel_token_copy = cancel_token;
            fromUuid(uuid).then((doc) => {
                if (!cancel_token_copy.canceled) {
                    DRAGGED_DOCUMENT.set(doc);
                }
            });
        },
        {
            capture: true, // We don't want people preventing us from seeing this!
            passive: true, // Improves performance. We only want to watch
        }
    );

    // Clear whenever we stop dragging anywhere. Have to handle both drag end and drop.
    const endListener = () => {
        DRAGGING.set(false);
        cancel_token.canceled = true;
        cancel_token = { canceled: false };
    };
    body.addEventListener("dragend", endListener, {
        capture: true, // Same as above
        passive: true,
    });
    body.addEventListener("drop", endListener, {
        capture: true, // Same as above
        passive: true,
    });
}
